import React, { useEffect, useRef, useState } from "react";
import { io } from "socket.io-client";

const Call = () => {
  const localVideoRef = useRef(null);
  const remoteVideoRefs = useRef({});
  const peerConnections = useRef({});
  const iceCandidatesBuffer = useRef({}); // Buffer ƒë·ªÉ l∆∞u ICE candidates
  const [userId, setUserId] = useState(null);
  const [targetUserIds, setTargetUserIds] = useState("");
  const [token, setToken] = useState("");
  const [socket, setSocket] = useState(null);
  const [stream, setStream] = useState(null);
  const [callStatus, setCallStatus] = useState("idle");

  const URL = "https://social-network-jbtx.onrender.com/call";
  const iceServers = {
    iceServers: [
      { urls: "stun:stun.l.google.com:19302" },
      { urls: "stun:openrelay.metered.ca:80" },
      {
        urls: "turn:openrelay.metered.ca:80",
        username: "openrelayproject",
        credential: "openrelayproject",
      },
      {
        urls: "turn:openrelay.metered.ca:443",
        username: "openrelayproject",
        credential: "openrelayproject",
      },
    ],
  };

  useEffect(() => {
    const getMediaDevices = async () => {
      try {
        const userStream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true,
        });
        console.log("‚úÖ [Media] ƒê√£ l·∫•y stream th√†nh c√¥ng");
        setStream(userStream);
        if (localVideoRef.current) {
          localVideoRef.current.srcObject = userStream;
        }
      } catch (err) {
        console.error("‚ùå [Media] L·ªói l·∫•y thi·∫øt b·ªã media:", err);
        alert("Kh√¥ng th·ªÉ truy c·∫≠p camera ho·∫∑c micro!");
      }
    };
    getMediaDevices();

    return () => {
      if (stream) {
        console.log("üßπ [Media] D·ªçn d·∫πp stream");
        stream.getTracks().forEach((track) => track.stop());
      }
    };
  }, []);

  useEffect(() => {
    if (!socket) return;

    socket.on("connect", () => {
      console.log("‚úÖ [Socket] K·∫øt n·ªëi WebSocket th√†nh c√¥ng");
      setCallStatus("connected");
    });

    socket.on("disconnect", () => {
      console.log("‚ùå [Socket] WebSocket ng·∫Øt k·∫øt n·ªëi");
      setCallStatus("disconnected");
      alert("M·∫•t k·∫øt n·ªëi v·ªõi server, vui l√≤ng th·ª≠ l·∫°i.");
      endCall();
    });

    socket.on("userId", ({ userId }) => {
      console.log("üÜî [Socket] Nh·∫≠n userId:", userId);
      setUserId(userId);
    });

    socket.on("incomingCall", ({ from, group }) => {
      console.log("üìû [Socket] Nh·∫≠n incomingCall t·ª´:", from, "group:", group);
      const accept = window.confirm(`üìû Cu·ªôc g·ªçi t·ª´ ${from}, ch·∫•p nh·∫≠n?`);
      if (accept) {
        setCallStatus("in-call");
        acceptCall(from, group);
      } else {
        console.log("‚ùå [Socket] G·ª≠i rejectCall t·ªõi:", from);
        socket.emit("rejectCall", { callerId: from });
      }
    });

    socket.on("callRejected", ({ from }) => {
      console.log("‚ùå [Socket] Nh·∫≠n callRejected t·ª´:", from);
      alert(`‚ùå Cu·ªôc g·ªçi t·ª´ ${from} ƒë√£ b·ªã t·ª´ ch·ªëi`);
      cleanupPeer(from);
      setCallStatus("idle");
    });

    socket.on("callEnded", ({ from }) => {
      console.log("üö´ [Socket] Nh·∫≠n callEnded t·ª´:", from);
      alert(`üö´ Cu·ªôc g·ªçi k·∫øt th√∫c b·ªüi ${from}`);
      cleanupPeer(from);
      setCallStatus("idle");
    });

    socket.on("callUnavailable", ({ message }) => {
      console.log("‚ùå [Socket] Nh·∫≠n callUnavailable:", message);
      alert(`‚ùå ${message}`);
      setCallStatus("idle");
    });

    socket.on("offer", async ({ from, sdp }) => {
      console.log("üì° [Socket] Nh·∫≠n offer t·ª´:", from, "SDP:", sdp);
      try {
        if (!peerConnections.current[from]) {
          peerConnections.current[from] = createPeerConnection(from);
        }
        await peerConnections.current[from].setRemoteDescription(new RTCSessionDescription(sdp));
        const answer = await peerConnections.current[from].createAnswer();
        await peerConnections.current[from].setLocalDescription(answer);
        console.log("üì° [Socket] G·ª≠i answer t·ªõi:", from, "SDP:", answer);
        socket.emit("answer", { targetUserId: from, sdp: answer });

        // X·ª≠ l√Ω ICE candidates trong buffer
        if (iceCandidatesBuffer.current[from]) {
          for (const candidate of iceCandidatesBuffer.current[from]) {
            console.log("‚ùÑÔ∏è [Socket] X·ª≠ l√Ω ICE candidate t·ª´ buffer cho:", from, "Candidate:", candidate);
            await peerConnections.current[from].addIceCandidate(new RTCIceCandidate(candidate));
          }
          delete iceCandidatesBuffer.current[from];
        }
      } catch (error) {
        console.error("‚ùå [Socket] L·ªói x·ª≠ l√Ω offer:", error);
        cleanupPeer(from);
      }
    });

    socket.on("answer", async ({ from, sdp }) => {
      console.log("üì° [Socket] Nh·∫≠n answer t·ª´:", from, "SDP:", sdp);
      try {
        if (!peerConnections.current[from]) return;
        await peerConnections.current[from].setRemoteDescription(new RTCSessionDescription(sdp));
        // X·ª≠ l√Ω ICE candidates trong buffer
        if (iceCandidatesBuffer.current[from]) {
          for (const candidate of iceCandidatesBuffer.current[from]) {
            console.log("‚ùÑÔ∏è [Socket] X·ª≠ l√Ω ICE candidate t·ª´ buffer cho:", from, "Candidate:", candidate);
            await peerConnections.current[from].addIceCandidate(new RTCIceCandidate(candidate));
          }
          delete iceCandidatesBuffer.current[from];
        }
      } catch (error) {
        console.error("‚ùå [Socket] L·ªói x·ª≠ l√Ω answer:", error);
        cleanupPeer(from);
      }
    });

    socket.on("ice-candidate", async ({ from, candidate }) => {
      console.log("‚ùÑÔ∏è [Socket] Nh·∫≠n ICE candidate t·ª´:", from, "Candidate:", candidate);
      try {
        if (!peerConnections.current[from]) {
          console.warn("‚ö†Ô∏è [Socket] PeerConnection cho", from, "ch∆∞a t·ªìn t·∫°i");
          return;
        }
        if (!peerConnections.current[from].remoteDescription) {
          console.log("‚è≥ [Socket] L∆∞u ICE candidate v√†o buffer cho:", from);
          if (!iceCandidatesBuffer.current[from]) iceCandidatesBuffer.current[from] = [];
          iceCandidatesBuffer.current[from].push(candidate);
          return;
        }
        await peerConnections.current[from].addIceCandidate(new RTCIceCandidate(candidate));
      } catch (error) {
        console.error("‚ùå [Socket] L·ªói x·ª≠ l√Ω ICE candidate:", error);
      }
    });

    return () => {
      console.log("üßπ [Socket] Ng·∫Øt k·∫øt n·ªëi socket");
      socket.disconnect();
      setSocket(null);
    };
  }, [socket, stream]);

  const connectSocket = () => {
    if (!token) return alert("Vui l√≤ng nh·∫≠p token");
    console.log("üîå [Socket] B·∫Øt ƒë·∫ßu k·∫øt n·ªëi v·ªõi token:", token);
    const newSocket = io(URL, {
      extraHeaders: { Authorization: `Bearer ${token}` },
    });
    setSocket(newSocket);
  };

  const createPeerConnection = (targetId) => {
    console.log("üîó [Peer] T·∫°o PeerConnection v·ªõi:", targetId);
    const pc = new RTCPeerConnection(iceServers);
    if (stream) {
      stream.getTracks().forEach((track) => {
        console.log("‚ûï [Peer] Th√™m track v√†o PeerConnection:", track.kind);
        pc.addTrack(track, stream);
      });
    }
    pc.onicecandidate = (e) => {
      if (e.candidate && socket) {
        console.log("‚ùÑÔ∏è [Peer] G·ª≠i ICE candidate t·ªõi:", targetId, "Candidate:", e.candidate);
        socket.emit("ice-candidate", { targetUserId: targetId, candidate: e.candidate });
      }
    };
    pc.ontrack = (e) => {
      console.log("üìπ [Peer] Nh·∫≠n stream t·ª´:", targetId);
      if (!remoteVideoRefs.current[targetId]) {
        const container = document.createElement("div");
        const video = document.createElement("video");
        const label = document.createElement("p");
        label.textContent = `User: ${targetId}`;
        video.autoplay = true;
        video.playsInline = true;
        video.style.width = "200px";
        container.appendChild(video);
        container.appendChild(label);
        document.getElementById("remote-videos").appendChild(container);
        remoteVideoRefs.current[targetId] = video;
      }
      remoteVideoRefs.current[targetId].srcObject = e.streams[0];
    };
    pc.oniceconnectionstatechange = () => {
      console.log("üåê [Peer] Tr·∫°ng th√°i ICE c·ªßa", targetId, ":", pc.iceConnectionState);
      if (pc.iceConnectionState === "disconnected" || pc.iceConnectionState === "failed") {
        console.log("‚ùå [Peer] K·∫øt n·ªëi ICE th·∫•t b·∫°i v·ªõi:", targetId);
        cleanupPeer(targetId);
      } else if (pc.iceConnectionState === "connected") {
        console.log("‚úÖ [Peer] K·∫øt n·ªëi ICE th√†nh c√¥ng v·ªõi:", targetId);
      }
    };
    return pc;
  };

  const startCall = async () => {
    if (!targetUserIds || !socket || !stream) return alert("Vui l√≤ng k·∫øt n·ªëi socket v√† b·∫≠t camera/micro");

    const ids = targetUserIds.split(",").map((id) => id.trim());
    if (ids.length > 5) return alert("T·ªëi ƒëa 5 ng∆∞·ªùi trong nh√≥m");

    console.log("üìû [Socket] G·ª≠i startCall t·ªõi:", ids);
    socket.emit("startCall", { targetUserIds: ids });
    setCallStatus("calling");

    for (const targetId of ids) {
      if (!peerConnections.current[targetId]) {
        peerConnections.current[targetId] = createPeerConnection(targetId);
        const offer = await peerConnections.current[targetId].createOffer();
        await peerConnections.current[targetId].setLocalDescription(offer);
        console.log("üì° [Socket] G·ª≠i offer t·ªõi:", targetId, "SDP:", offer);
        socket.emit("offer", { targetUserId: targetId, sdp: offer });
      }
    }
  };

  const acceptCall = async (callerId, group) => {
    console.log("‚úÖ [Call] Ch·∫•p nh·∫≠n cu·ªôc g·ªçi t·ª´:", callerId, "group:", group);
    group.forEach((id) => {
      if (id !== userId && !peerConnections.current[id]) {
        peerConnections.current[id] = createPeerConnection(id);
      }
    });
  };

  const endCall = () => {
    console.log("üö´ [Socket] G·ª≠i endCall");
    Object.keys(peerConnections.current).forEach((targetId) => cleanupPeer(targetId));
    if (socket) socket.emit("endCall");
    setCallStatus("idle");
  };

  const cleanupPeer = (targetId) => {
    console.log("üßπ [Peer] D·ªçn d·∫πp PeerConnection v·ªõi:", targetId);
    if (peerConnections.current[targetId]) {
      peerConnections.current[targetId].close();
      delete peerConnections.current[targetId];
    }
    if (remoteVideoRefs.current[targetId]) {
      remoteVideoRefs.current[targetId].srcObject = null;
      remoteVideoRefs.current[targetId].parentElement.remove();
      delete remoteVideoRefs.current[targetId];
    }
    if (iceCandidatesBuffer.current[targetId]) {
      delete iceCandidatesBuffer.current[targetId];
    }
  };

  return (
    <div>
      <h2>üìû Video Call Demo</h2>
      <p>Tr·∫°ng th√°i: {callStatus}</p>

      <div>
        <label>Token: </label>
        <input value={token} onChange={(e) => setToken(e.target.value)} />
        <button onClick={connectSocket} disabled={socket}>K·∫øt n·ªëi</button>
      </div>

      <div>
        <label>G·ªçi t·ªõi ID (c√°ch nhau b·∫±ng ","): </label>
        <input value={targetUserIds} onChange={(e) => setTargetUserIds(e.target.value)} />
        <button onClick={startCall} disabled={callStatus === "in-call" || !socket}>G·ªçi</button>
        <button onClick={endCall} disabled={callStatus === "idle"}>K·∫øt th√∫c</button>
      </div>

      <div style={{ display: "flex", gap: "20px", marginTop: "20px" }}>
        <div>
          <h4>üë§ Video c·ªßa b·∫°n</h4>
          <video ref={localVideoRef} autoPlay playsInline muted width="300" />
        </div>
        <div>
          <h4>üë• Video nh√≥m</h4>
          <div
            id="remote-videos"
            style={{ display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(200px, 1fr))", gap: "10px" }}
          ></div>
        </div>
      </div>
    </div>
  );
};

export default Call;